{"id":"game-loop.js","dependencies":[{"name":"/Users/birusnt/Development/draw-with-friends-api/package.json","includedInParent":true,"mtime":1598979062184},{"name":"./words.json","loc":{"line":2,"column":22},"parent":"/Users/birusnt/Development/draw-with-friends-api/game-loop.js","resolved":"/Users/birusnt/Development/draw-with-friends-api/words.json"},{"name":"./services/room","loc":{"line":4,"column":28},"parent":"/Users/birusnt/Development/draw-with-friends-api/game-loop.js","resolved":"/Users/birusnt/Development/draw-with-friends-api/services/room.js"}],"generated":{"js":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst _ = require('lodash');\n\nconst words = require('./words.json');\n\nconst LOG = true;\n\nconst roomService = require('./services/room');\n\nconst defaultGameState = {\n  timer: 0,\n  turnIndex: 1,\n  round: 1,\n  roundWord: '',\n  numberOfRounds: 5,\n  numberOfTurns: 4,\n  roundTimer: 10\n};\n\nconst game = function (room, endGame) {\n  // init game state\n  room.gameState = _.cloneDeep(defaultGameState);\n  room.gameState.numberOfTurns = Object.keys(room.users).length;\n  let timerInterval = null;\n\n  function loop() {\n    log('loop', `${room.gameState.round}/${room.gameState.round}`); // create new word\n\n    room.gameState.roundWord = getRandomWord(); // reset user info\n\n    Object.keys(room.users).forEach(userid => {\n      room.users[userid].match = false;\n      room.users[userid].guesses = [];\n    }); // update room\n\n    broadcastRoomUpdate(room); // broadcast loop start\n\n    broadcastEvent(_objectSpread({\n      event: 'pre_round'\n    }, room.gameState)); // wait 3 seconds before starting next round\n\n    startTimer(3, startRound);\n  } // actions\n\n\n  function startRound() {\n    broadcastEvent({\n      event: 'round_start'\n    }); // start round timer\n\n    startTimer(room.gameState.roundTimer, endRound);\n  }\n\n  function endRound() {\n    broadcastEvent({\n      event: 'round_end'\n    }); // move round count down, next user turn\n\n    room.gameState.round++; // update turn\n\n    incrementTurnIndex(); // check to see if game is over\n\n    if (room.gameState.round > room.gameState.numberOfRounds) {\n      endGame();\n    } else {\n      // allow 3 seconds of endtime\n      startTimer(3, loop);\n    }\n  }\n\n  function guess(data, cb) {\n    let roundWordMatch = data.guess && data.guess.toUpperCase() === room.gameState.roundWord.toUpperCase();\n    cb(roundWordMatch);\n  } // helpers\n\n\n  function startTimer(timerLength, cb) {\n    // set timer length\n    room.gameState.timer = timerLength; // set timer interval\n\n    timerInterval = setInterval(() => {\n      updateTimer(cb);\n    }, 1000);\n  }\n\n  function updateTimer(cb) {\n    if (room.gameState.timer === -1) {\n      clearTimer();\n      cb();\n    } else {\n      broadcastTimer();\n      room.gameState.timer--;\n    }\n  }\n\n  function clearTimer() {\n    clearInterval(timerInterval);\n    timerInterval = null;\n    timerCallback = null;\n  }\n\n  function incrementTurnIndex() {\n    if (room.gameState.turnIndex === room.gameState.numberOfTurns) {\n      room.gameState.turnIndex = 1;\n    } else {\n      room.gameState.turnIndex++;\n    }\n  }\n\n  function getRandomWord() {\n    return words[Math.floor(Math.random() * words.length)];\n  } // broadcasts\n\n\n  function broadcastTimer() {\n    for (const client of room.sockets) {\n      client.emit('update_game_timer', room.gameState.timer);\n    }\n  }\n\n  function broadcastEvent(event) {\n    log('broadcast-event', event.event);\n\n    for (const client of room.sockets) {\n      client.emit('update_game_event', event);\n    }\n  }\n\n  function broadcastRoomUpdate(room) {\n    log('broadcast-room-update', room.roomid);\n\n    for (const client of room.sockets) {\n      client.emit('update_room', formatRoom(room));\n    }\n  } // start game\n\n\n  loop(); // expose functions\n\n  return {\n    guess\n  };\n};\n\nmodule.exports = game; // helpers\n\nfunction log(message, roomid, userid) {\n  if (LOG) {\n    if (userid) {\n      console.log(`game:${message}`, roomid, userid);\n    } else {\n      console.log(`game:${message}`, roomid);\n    }\n  }\n}\n\nfunction formatRoom(room) {\n  return _.cloneDeep(_objectSpread(_objectSpread({}, room), {}, {\n    game: null,\n    sockets: []\n  }));\n}"},"sourceMaps":null,"error":null,"hash":"3fc465079ba496c8d9b893d5c034ac06","cacheData":{"env":{}}}