{"id":"services/room.js","dependencies":[{"name":"D:\\Development\\draw-with-friends-api\\package.json","includedInParent":true,"mtime":1599100314966},{"name":"../socket.js","loc":{"line":1,"column":19},"parent":"D:\\Development\\draw-with-friends-api\\services\\room.js","resolved":"D:\\Development\\draw-with-friends-api\\socket.js"},{"name":"./global","loc":{"line":2,"column":23},"parent":"D:\\Development\\draw-with-friends-api\\services\\room.js","resolved":"D:\\Development\\draw-with-friends-api\\services\\global.js"},{"name":"./game","loc":{"line":3,"column":21},"parent":"D:\\Development\\draw-with-friends-api\\services\\room.js","resolved":"D:\\Development\\draw-with-friends-api\\services\\game.js"},{"name":"../colors","loc":{"line":4,"column":23},"parent":"D:\\Development\\draw-with-friends-api\\services\\room.js","resolved":"D:\\Development\\draw-with-friends-api\\colors.js"},{"name":"../game-loop","loc":{"line":5,"column":25},"parent":"D:\\Development\\draw-with-friends-api\\services\\room.js","resolved":"D:\\Development\\draw-with-friends-api\\game-loop.js"}],"generated":{"js":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst io = require('../socket.js').getio();\n\nconst global = require('./global');\n\nconst game = require('./game');\n\nconst colors = require('../colors').default;\n\nconst gameLoop = require('../game-loop');\n\nconst _ = require('lodash');\n\nconst LOG = false;\nconst DISABLE_READY = false; // vars\n\nconst defaultRoom = {\n  game: gameLoop,\n  name: '',\n  roomid: '',\n  userid: '',\n  active: false,\n  users: {},\n  sockets: [],\n  messages: [],\n  gameState: {}\n};\nconst defaultRoomUser = {\n  guesses: [],\n  connected: true,\n  ready: false,\n  match: false,\n  color: '',\n  score: 0\n}; // socket events\n\nio.on('connection', socket => {\n  socket.on('create_room', room => createRoom(room, socket));\n  socket.on('remove_room', roomid => removeRoom(roomid));\n  socket.on('join_room', roomid => joinRoom(roomid, socket));\n  socket.on('leave_room', roomid => leaveRoom(roomid, socket));\n  socket.on('room_message', data => roomMessage(data, socket));\n  socket.on('ready', flag => setReady(flag, socket));\n  socket.on('color', color => setColor(color, socket)); // remove from room if disconnected\n\n  socket.on('disconnecting', () => {\n    if (socket.roomid) {\n      leaveRoom(socket.roomid, socket);\n    }\n  });\n}); // event handlers\n\nfunction createRoom(room, socket) {\n  log('create-room', room.roomid, socket.userid);\n  global.addRoom(_objectSpread(_objectSpread({}, _.cloneDeep(defaultRoom)), room));\n}\n\nfunction removeRoom(roomid) {\n  log('remove-room', roomid);\n  game.endGame(global.rooms[roomid]);\n  global.removeRoom(roomid);\n}\n\nfunction joinRoom(roomid, socket) {\n  log('join-room', roomid, socket.userid); // get connecting user/room\n\n  let user = global.users[socket.userid];\n  let room = global.rooms[roomid];\n\n  if (room === undefined || user === undefined) {\n    log('join-room-error', roomid, socket.userid);\n    broadcastJoinError(socket);\n    return;\n  } // add roomid to user\n\n\n  user.roomid = roomid; // add socket\n\n  room.sockets.push(socket); // if user already exists, set to connected\n\n  if (Object.keys(room.users).includes(user.userid)) {\n    room.users[user.userid].connected = true;\n  } else {\n    room.users[user.userid] = _objectSpread(_objectSpread({}, _.cloneDeep(defaultRoomUser)), user);\n  } // add color to user\n\n\n  room.users[user.userid].color = getColor(room.users); // join room\n\n  socket.join(roomid, () => {\n    socket.roomid = roomid; // brodcast join\n\n    roomMessage({\n      event: 'join',\n      userid: user.userid,\n      user\n    }, socket);\n  });\n  broadcastRoomJoin(room, socket);\n  broadcastRoomUpdate(room);\n  global.broadcastRooms();\n\n  if (room.active) {\n    game.broadcastRoomUpdate(room);\n  }\n}\n\nfunction leaveRoom(roomid, socket) {\n  log('leave-room', roomid, socket.userid); // get connecting user/room\n\n  let user = global.users[socket.userid];\n  let room = global.rooms[roomid];\n\n  if (room === undefined || user === undefined) {\n    log('leave-room-error', roomid, socket.userid);\n    return;\n  } // brodcast join\n\n\n  roomMessage({\n    event: 'leave',\n    userid: user.userid,\n    user\n  }, socket); // leave room\n\n  socket.leave(roomid, () => {\n    socket.roomid = '';\n  }); // remove roomid from user\n\n  user.roomid = '';\n  let roomUsersLength = Object.keys(room.users).length;\n  let isHost = room.userid === user.userid; // if the game is inactive, remove the user completely\n\n  if (!room.active) {\n    delete room.users[user.userid];\n  } else {\n    room.users[user.userid].connected = false;\n  } // if there is only one user in the room, delete the room\n\n\n  if (roomUsersLength === 1 || Object.values(room.users).every(u => !u.connected)) {\n    removeRoom(roomid);\n  } else {\n    // remove socket\n    const index = room.sockets.findIndex(s => s.id === socket.id);\n\n    if (index > -1) {\n      room.sockets.splice(index, 1);\n    } // if host, replace with another user\n\n\n    if (isHost) {\n      room.userid = room.users[Object.keys(room.users)[0]].userid;\n    }\n  }\n\n  broadcastRoomUpdate(room);\n  global.broadcastRooms();\n}\n\nfunction setReady(flag, socket) {\n  log('user-ready', socket.roomid, socket.userid);\n  let room = global.rooms[socket.roomid];\n\n  if (room === undefined) {\n    log('user-ready-error', socket.roomid, socket.userid);\n    return;\n  }\n\n  let userValues = Object.values(room.users); // set to flag on user\n\n  room.users[socket.userid].ready = flag;\n\n  if (flag) {\n    roomMessage({\n      user: global.users[socket.userid],\n      event: 'ready',\n      userid: socket.userid\n    }, socket);\n  } else {\n    cancelCountDown(socket);\n    roomMessage({\n      user: global.users[socket.userid],\n      event: 'not-ready',\n      userid: socket.userid\n    }, socket);\n  } // if all 4 players are ready, start game\n\n\n  if (userValues.length > 1 && userValues.every(r => r.ready) || DISABLE_READY) {\n    room.active = true;\n    startCountDown(game, room, socket);\n  }\n\n  broadcastRoomUpdate(room);\n  global.broadcastRooms();\n}\n\nfunction setColor(color, socket) {\n  log('color', socket.roomid, socket.userid);\n  let room = global.rooms[socket.roomid];\n\n  if (room === undefined) {\n    log('user-color-error', socket.roomid, socket.userid);\n    return;\n  } // set color\n\n\n  room.users[socket.userid].color = color;\n  broadcastRoomUpdate(room);\n  global.broadcastRooms();\n}\n\nfunction roomMessage(data, socket) {\n  let room = global.rooms[socket.roomid];\n\n  if (data.event === 'not-ready') {\n    room.messages.forEach((message, i) => {\n      if (data.userid === message.userid && message.event === 'ready') {\n        room.messages.splice(i, 1);\n      }\n    });\n  } else if (data.message || data.event) {\n    room.messages.push({\n      user: global.users[data.userid],\n      message: data.message,\n      event: data.event,\n      userid: data.userid\n    });\n  }\n\n  broadcastRoomUpdate(room);\n}\n\nlet countDownInterval = null;\n\nfunction startCountDown(game, room, socket) {\n  let count = 3;\n  countDown();\n  countDownInterval = setInterval(countDown, 1250);\n\n  function countDown() {\n    roomMessage({\n      event: 'countdown',\n      message: count,\n      userid: socket.userid\n    }, socket);\n\n    if (count === 0) {\n      clearInterval(countDownInterval);\n      countDownInterval = null;\n      game.startGame(room);\n    }\n\n    count--;\n  }\n}\n\nfunction cancelCountDown(socket) {\n  if (countDownInterval) {\n    clearInterval(countDownInterval);\n    countDownInterval = null;\n    roomMessage({\n      event: 'countdown-cancel',\n      userid: socket.userid\n    }, socket);\n  }\n} // broadcasts\n\n\nfunction broadcastRoomJoin(room, socket) {\n  log('broadcast-room-join', room.roomid, socket.userid);\n  socket.emit('join_room', formatRoom(room));\n}\n\nfunction broadcastJoinError(socket) {\n  socket.emit('join_room_error');\n}\n\nfunction broadcastRoomUpdate(room) {\n  log('broadcast-room-update', room.roomid);\n\n  for (const client of room.sockets) {\n    client.emit('update_room', formatRoom(room));\n  }\n} // helpers\n\n\nfunction log(message, roomid, userid) {\n  if (LOG) {\n    if (userid) {\n      console.log(`room:${message}`, roomid, userid);\n    } else {\n      console.log(`room:${message}`, roomid);\n    }\n  }\n}\n\nfunction formatRoom(room) {\n  return _.cloneDeep(_objectSpread(_objectSpread({}, room), {}, {\n    game: null,\n    sockets: []\n  }));\n}\n\nfunction getColor(users) {\n  let activeIndexes = [];\n\n  for (let userid in users) {\n    let color = users[userid].color;\n    let colorIndex = colors.findIndex(c => c === color);\n\n    if (colorIndex !== -1) {\n      activeIndexes.push(colorIndex);\n    }\n  }\n\n  function generateRandom(min, max) {\n    var num = Math.floor(Math.random() * (max - min + 1)) + min;\n    return activeIndexes.includes(num) ? generateRandom(min, max) : num;\n  }\n\n  return colors[generateRandom(0, 5)];\n} // exports\n\n\nmodule.exports = {\n  broadcastRoomUpdate\n};"},"sourceMaps":null,"error":null,"hash":"7a30ab44f1bbbbf6ceff14a1ba647bac","cacheData":{"env":{}}}