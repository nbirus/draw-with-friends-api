{"id":"services/room.js","dependencies":[{"name":"/Users/birusnt/Development/draw-with-friends-api/package.json","includedInParent":true,"mtime":1598979062184},{"name":"../socket.js","loc":{"line":1,"column":19},"parent":"/Users/birusnt/Development/draw-with-friends-api/services/room.js","resolved":"/Users/birusnt/Development/draw-with-friends-api/socket.js"},{"name":"./global","loc":{"line":2,"column":23},"parent":"/Users/birusnt/Development/draw-with-friends-api/services/room.js","resolved":"/Users/birusnt/Development/draw-with-friends-api/services/global.js"},{"name":"./game","loc":{"line":3,"column":21},"parent":"/Users/birusnt/Development/draw-with-friends-api/services/room.js","resolved":"/Users/birusnt/Development/draw-with-friends-api/services/game.js"},{"name":"../game-loop","loc":{"line":4,"column":25},"parent":"/Users/birusnt/Development/draw-with-friends-api/services/room.js","resolved":"/Users/birusnt/Development/draw-with-friends-api/game-loop.js"}],"generated":{"js":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst io = require('../socket.js').getio();\n\nconst global = require('./global');\n\nconst game = require('./game');\n\nconst gameLoop = require('../game-loop');\n\nconst _ = require('lodash');\n\nconst LOG = true;\nconst DISABLE_READY = true; // vars\n\nconst defaultRoom = {\n  game: gameLoop,\n  name: '',\n  roomid: '',\n  userid: '',\n  colors: [],\n  active: false,\n  users: {},\n  sockets: [],\n  messages: [],\n  guesses: [],\n  settings: {\n    numberOfRounds: 5,\n    roundTimerLength: 10\n  }\n};\nconst defaultRoomUser = {\n  connected: true,\n  ready: false,\n  match: false,\n  score: 0\n}; // socket events\n\nio.on('connection', socket => {\n  socket.on('create_room', room => createRoom(room, socket));\n  socket.on('remove_room', roomid => removeRoom(roomid));\n  socket.on('join_room', roomid => joinRoom(roomid, socket));\n  socket.on('leave_room', roomid => leaveRoom(roomid, socket));\n  socket.on('ready', flag => setReady(flag, socket)); // remove from room if disconnected\n\n  socket.on('disconnecting', () => {\n    if (socket.roomid) {\n      leaveRoom(socket.roomid, socket);\n    }\n  });\n}); // event handlers\n\nfunction createRoom(room, socket) {\n  log('create-room', room.roomid, socket.userid);\n  global.addRoom(_objectSpread(_objectSpread({}, _.cloneDeep(defaultRoom)), room));\n}\n\nfunction removeRoom(roomid) {\n  log('remove-room', roomid);\n  global.removeRoom(roomid);\n}\n\nfunction joinRoom(roomid, socket) {\n  log('join-room', roomid, socket.userid); // get connecting user/room\n\n  let user = global.users[socket.userid];\n  let room = global.rooms[roomid];\n\n  if (room === undefined || user === undefined) {\n    log('join-room-error', roomid, socket.userid);\n    brodcastJoinError(socket);\n    return;\n  } // add roomid to user\n\n\n  user.roomid = roomid; // add socket\n\n  room.sockets.push(socket); // if user already exists, set to connected\n\n  if (Object.keys(room.users).includes(user.userid)) {\n    room.users[user.userid].connected = true;\n  } else {\n    room.users[user.userid] = _objectSpread(_objectSpread({}, _.cloneDeep(defaultRoomUser)), user);\n  } // join room\n\n\n  socket.join(roomid, () => {\n    socket.roomid = roomid;\n  });\n  brodcastRoomJoin(room, socket);\n  brodcastRoomUpdate(room);\n  global.brodcastRooms();\n}\n\nfunction leaveRoom(roomid, socket) {\n  log('leave-room', roomid, socket.userid); // get connecting user/room\n\n  let user = global.users[socket.userid];\n  let room = global.rooms[roomid];\n\n  if (room === undefined || user === undefined) {\n    log('leave-room-error', roomid, socket.userid);\n    return;\n  } // leave room\n\n\n  socket.leave(roomid, () => {\n    socket.roomid = '';\n  }); // remove roomid from user\n\n  user.roomid = '';\n  let roomUsersLength = Object.keys(room.users).length;\n  let isHost = room.userid === user.userid; // if there is only one user in the room, delete the room\n\n  if (roomUsersLength === 1) {\n    removeRoom(roomid);\n  } else {\n    // remove socket\n    const index = room.sockets.findIndex(s => s.id === socket.id);\n\n    if (index > -1) {\n      room.sockets.splice(index, 1);\n    } // if host, replace with another user\n\n\n    if (isHost) {\n      room.userid = room.users[Object.keys(room.users)[0]].userid;\n    } // if the game is inactive, remove the user completely\n\n\n    if (!room.active) {\n      delete room.users[user.userid];\n    } else {\n      room.users[user.userid].connected = false;\n    }\n  }\n\n  brodcastRoomUpdate(room);\n  global.brodcastRooms();\n}\n\nfunction setReady(flag, socket) {\n  log('user-ready', socket.roomid, socket.userid);\n  let room = global.rooms[socket.roomid];\n  let userValues = Object.values(room.users); // set to flag on user\n\n  room.users[socket.userid].ready = flag; // if all 4 players are ready, start game\n\n  if (userValues.length === 4 && userValues.every(r => r.ready) || DISABLE_READY) {\n    room.active = true;\n    game.startGame(room);\n  }\n\n  brodcastRoomUpdate(room);\n  global.brodcastRooms();\n} // brodcasts\n\n\nfunction brodcastRoomJoin(room, socket) {\n  log('brodcast-room-join', room.roomid, socket.userid);\n  socket.emit('join_room', formatRoom(room));\n}\n\nfunction brodcastJoinError(socket) {\n  socket.emit('join_room_error');\n}\n\nfunction brodcastRoomUpdate(room) {\n  log('brodcast-room-update', room.roomid);\n\n  for (const client of room.sockets) {\n    client.emit('update_room', formatRoom(room));\n  }\n} // helpers\n\n\nfunction log(message, roomid, userid) {\n  if (LOG) {\n    if (userid) {\n      console.log(`room:${message}`, roomid, userid);\n    } else {\n      console.log(`room:${message}`, roomid);\n    }\n  }\n}\n\nfunction formatRoom(room) {\n  return _.cloneDeep(_objectSpread(_objectSpread({}, room), {}, {\n    game: null,\n    sockets: []\n  }));\n} // exports\n\n\nmodule.exports = {};"},"sourceMaps":null,"error":null,"hash":"aa6ffd0437be02da8b411fe1c44d2f18","cacheData":{"env":{}}}